<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel TV Shuffler - Retro Style</title>
    <!-- Load Pixel Font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <!-- Google Identity Services Library -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        /* --- CSS Variables (Palette & Sizing) --- */
        :root {
            /* Colors based on reference image */
            --bg-color-1: #EFBCD5;   /* Soft pink */
            --bg-color-2: #3185FC;   /* Lavender */
            --bg-color-3: #F9DC5C;   /* Light orange */
            --tv-body: #E84855;     /* Light orange (TV Body) */
            --tv-outline: #403F4C;   /* Dark gray (Outline) */
            --panel-bg: #3185FC;    /* Muted green (Panel/Bezel) */
            --panel-highlight: #EFBCD5; /* Lavender (Bezel Highlight) */
            --knob-center: #F9DC5C; /* Soft pink (Knob detail) */
            --screen-bg: #403F4C;   /* Muted green (Video Player Background) */
            --loading-text: #ffffff;/* White */
            --button-text: #F9DC5C; /* Match knob center for consistency */
            --button-disabled-bg: #a8323c; /* Darker red for disabled */
            --button-disabled-text: #d3a8ae; /* Muted pink for disabled text */

            /* Dimmed mode colors */
            --dimmed-overlay: rgba(0, 0, 0, 0.65); /* Black overlay with 65% opacity */

            /* Pattern size */
            --pattern-size: calc(var(--pixel-unit) * 30);

            /* Base size for pixel blocks */
            --pixel-unit: 9px;

            /* Derived sizes based on pixel unit */
            --border-width: calc(var(--pixel-unit) * 0.75);
            --outline-width: calc(var(--pixel-unit) * 0.75);
            --element-gap: calc(var(--pixel-unit) * 3); /* Increased gap slightly for new button */

            /* Animated pattern properties */
            --a: 0deg;
            --p: 0%;
            --c1: var(--bg-color-1);
            --c2: var(--bg-color-2);
        }

        /* Custom properties for animation */
        @property --a {
            syntax: '<angle>';
            inherits: true;
            initial-value: 0deg;
        }

        @property --p {
            syntax: '<percentage>';
            inherits: true;
            initial-value: 0%;
        }

        @property --c1 {
            syntax: '<color>';
            inherits: true;
            initial-value: var(--bg-color-1);
        }

        @property --c2 {
            syntax: '<color>';
            inherits: true;
            initial-value: var(--bg-color-2);
        }

        /* --- Basic Setup & Pixel Rendering --- */
        body {
            margin: 0;
            padding: calc(var(--pixel-unit) * 2) 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            transition: all 4s ease;
            box-sizing: border-box;
            position: relative;
            --_g: #0000, var(--c1) 2deg calc(var(--a) - 2deg), #0000 var(--a);
            background:
                conic-gradient(from calc(-45deg  - var(--a)/2) at top    var(--p) left  var(--p), var(--_g)),
                conic-gradient(from calc(-45deg  - var(--a)/2) at top    var(--p) left  var(--p), var(--_g)),
                conic-gradient(from calc( 45deg  - var(--a)/2) at top    var(--p) right var(--p), var(--_g)),
                conic-gradient(from calc( 45deg  - var(--a)/2) at top    var(--p) right var(--p), var(--_g)),
                conic-gradient(from calc(-135deg - var(--a)/2) at bottom var(--p) left  var(--p), var(--_g)),
                conic-gradient(from calc(-135deg - var(--a)/2) at bottom var(--p) left  var(--p), var(--_g)),
                conic-gradient(from calc( 135deg - var(--a)/2) at bottom var(--p) right var(--p), var(--_g)),
                conic-gradient(from calc( 135deg - var(--a)/2) at bottom var(--p) right var(--p), var(--_g))
                var(--c2);
            background-size: calc(2*var(--pattern-size)) calc(2*var(--pattern-size));
            animation: patternAnimation 10s infinite alternate linear;
        }

        /* Dimmed state for body */
        body.dimmed {
            background-color: #222;
            animation: none;
        }

        @keyframes patternAnimation {
            0%, 15% {
                --a: 135deg;
                --p: 20%;
                --c1: var(--bg-color-1);
                --c2: var(--bg-color-2);
                background-position: 0 0, var(--pattern-size) var(--pattern-size);
            }
            45%, 50% {
                --a: 90deg;
                --p: 25%;
                --c1: var(--bg-color-1);
                --c2: var(--bg-color-2);
                background-position: 0 0, var(--pattern-size) var(--pattern-size);
            }
            50.01%, 55% {
                --a: 90deg;
                --p: 25%;
                --c2: var(--bg-color-1);
                --c1: var(--bg-color-2);
                background-position: var(--pattern-size) 0, 0 var(--pattern-size);
            }
            85%, 100% {
                --a: 135deg;
                --p: 20%;
                --c2: var(--bg-color-1);
                --c1: var(--bg-color-2);
                background-position: var(--pattern-size) 0, 0 var(--pattern-size);
            }
        }

        /* Ensure content stays above pattern */
        .tv-container, .main-heading, .auth-controls { /* Added auth-controls */
            position: relative;
            z-index: 1;
        }

        /* --- Auth Controls (Sign In/Out) --- */
        .auth-controls {
            position: absolute;
            top: calc(var(--pixel-unit) * 1); /* Position near the top */
            right: calc(var(--pixel-unit) * 2);
            z-index: 20; /* Ensure it's above TV */
            display: flex;
            gap: calc(var(--pixel-unit) * 1);
        }

        /* Style for the Sign Out button to match TV aesthetic */
        #signout-button {
            font-family: 'Press Start 2P', cursive;
            font-size: calc(var(--pixel-unit) * 1.2);
            padding: calc(var(--pixel-unit) * 0.8) calc(var(--pixel-unit) * 1.5);
            background-color: var(--tv-body);
            color: var(--button-text);
            border: var(--outline-width) solid var(--tv-outline);
            border-radius: var(--pixel-unit);
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: calc(var(--pixel-unit) * 0.4) calc(var(--pixel-unit) * 0.4) 0 var(--tv-outline);
            transition: transform 0.1s ease, filter 0.1s ease;
        }

        #signout-button:hover {
            filter: brightness(1.1);
        }

        #signout-button:active {
            transform: translate(calc(var(--pixel-unit) * 0.2), calc(var(--pixel-unit) * 0.2));
            box-shadow: calc(var(--pixel-unit) * 0.2) calc(var(--pixel-unit) * 0.2) 0 var(--tv-outline);
            filter: brightness(0.9);
        }

        /* --- Main Heading --- */
        .main-heading {
            font-family: 'Press Start 2P', cursive;
            font-size: calc(var(--pixel-unit) * 3);
            color: var(--loading-text);
            text-shadow:
               calc(var(--pixel-unit) * 0.5) calc(var(--pixel-unit) * 0.5) 0 var(--tv-outline),
               calc(var(--pixel-unit) * 0.5) calc(var(--pixel-unit) * 0.5) 0 rgba(0,0,0,0.3);
            margin: 0 0 calc(var(--pixel-unit) * 6) 0;
            padding: calc(var(--pixel-unit) * 2);
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: absolute;
             /* Adjust top positioning slightly to accommodate auth buttons */
            top: calc(var(--pixel-unit) * 5);
            z-index: 1;
            width: 100%;
            box-sizing: border-box;
        }


        /* --- TV Container --- */
        .tv-container {
            position: absolute;
            width: calc(var(--pixel-unit) * 90);
            height: calc(var(--pixel-unit) * 55);
            transition: all 0.5s ease;
            /* Added margin-top to push TV down slightly */
            margin-top: calc(var(--pixel-unit) * 10);
        }

        .tv-container.dimmed {
            filter: brightness(1.2) contrast(1.1);
        }

        /* --- TV Body --- */
        .tv-body {
            width: 100%;
            height: 100%;
            background-color: var(--tv-body);
            border: var(--outline-width) solid var(--tv-outline);
            border-radius: calc(var(--pixel-unit) * 3);
            display: flex;
            padding: calc(var(--element-gap) * 1.5);
            box-sizing: border-box;
            position: relative;
            box-shadow:
                calc(var(--pixel-unit) * 0.8) calc(var(--pixel-unit) * 0.8) 0 var(--tv-outline),
                calc(var(--pixel-unit) * 1.5) calc(var(--pixel-unit) * 1.5) 0 rgba(0,0,0,0.2);
        }

        /* --- Screen Area (Left Side) --- */
        .screen-area {
            flex-grow: 1;
            height: 100%;
            align-self: center;
            background-color: var(--screen-bg);
            border: var(--border-width) solid var(--tv-outline);
            border-radius: calc(var(--pixel-unit)*3);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: calc(var(--pixel-unit) * 1.5);
            box-sizing: border-box;
            box-shadow: inset 0 0 0 var(--pixel-unit) var(--panel-highlight);
            position: relative;
        }

        .screen {
            width: 98%;
            height: 98%;
            background-color: var(--screen-bg);
            overflow: hidden;
            position: relative;
            border-radius: calc(var(--pixel-unit)*3);
        }

        /* --- Controls Panel (Right Side) --- */
        .controls-panel {
            width: calc(var(--pixel-unit) * 22);
            height: 100%;
            background-color: var(--panel-bg);
            border: var(--outline-width) solid var(--tv-outline);
            border-radius: calc(var(--pixel-unit)*3);
            margin-left: var(--element-gap);
            display: flex;
            flex-direction: column;
            /* Adjust justification to make space for new button */
            justify-content: space-between; /* Use space-between */
            align-items: center;
            /* Adjusted padding slightly */
            padding: calc(var(--element-gap) * 1.2) 0;
            box-sizing: border-box;
        }

        /* --- Container for control + label --- */
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            width: 100%; /* Ensure groups take full width for spacing */
        }

        /* --- Style for the labels --- */
        .control-label {
            font-family: 'Press Start 2P', cursive;
            font-size: calc(var(--pixel-unit) * 1);
            color: var(--knob-center);
            /* Reduced margins slightly to fit 4 controls */
            margin-top: calc(var(--pixel-unit) * 1.0);
            margin-bottom: calc(var(--pixel-unit) * 1.0);
            text-transform: uppercase;
            letter-spacing: 1px;
            line-height: 1.2;
        }

        /* --- Individual Controls --- */
        .control {
            background-color: var(--tv-body);
            border: var(--outline-width) solid var(--tv-outline);
            position: relative;
            box-sizing: border-box;
            cursor: pointer;
            image-rendering: pixelated;
            display: flex; /* Added for centering text/icon in button */
            justify-content: center; /* Center content horizontally */
            align-items: center; /* Center content vertically */
        }
        .control:active:not(:disabled) { /* Disable active effect when disabled */
            filter: brightness(0.9);
            transform: translateY(calc(var(--pixel-unit) * 0.2));
        }

        /* Top Knob (Channel) */
        .knob-1 {
            width: calc(var(--pixel-unit) * 10); /* Reduced size slightly */
            height: calc(var(--pixel-unit) * 10);
            border-radius: 50%;
        }
        .knob-1::after {
            content: '';
            position: absolute;
            width: calc(var(--pixel-unit) * 6); /* Reduced size slightly */
            height: calc(var(--pixel-unit) * 6);
            background-color: var(--knob-center);
            border: var(--outline-width) solid var(--tv-outline);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Middle Knob (Mute/Volume) */
        .knob-2 {
            width: calc(var(--pixel-unit) * 9); /* Reduced size slightly */
            height: calc(var(--pixel-unit) * 9);
            border-radius: 50%;
        }
        .knob-2::after, .knob-2::before {
            content: '';
            position: absolute;
            width: 70%;
            height: var(--border-width);
            background-color: var(--knob-center);
            border: calc(var(--outline-width) * 0.8) solid var(--tv-outline);
            border-radius: var(--pixel-unit);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-45deg);
        }
        .knob-2::before {
            transform: translate(-50%, -50%) rotate(45deg);
            z-index: 1;
            background-color: var(--knob-center);
        }

        /* --- NEW Save Button --- */
        #save-watch-later-button {
            width: calc(var(--pixel-unit) * 9);
            height: calc(var(--pixel-unit) * 9);
            border-radius: var(--pixel-unit);
            background-color: var(--tv-body);
            border: var(--outline-width) solid var(--tv-outline);
            color: var(--button-text);
            font-family: 'Press Start 2P', cursive;
            font-size: calc(var(--pixel-unit) * 1.5);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #save-watch-later-button:disabled {
            background-color: var(--button-disabled-bg);
            color: var(--button-disabled-text);
            cursor: not-allowed;
            filter: grayscale(50%);
        }


        /* Bottom Slider (Dim Lights) */
        .slider {
            width: calc(var(--pixel-unit) * 10); /* Reduced size slightly */
            height: calc(var(--pixel-unit) * 5);
            border-radius: calc(var(--pixel-unit) * 2);
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            padding: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 auto;
        }

        .slider:active {
            filter: brightness(0.9);
            transform: translateY(calc(var(--pixel-unit) * 0.2));
        }

        .slider-line {
            width: 70%;
            height: var(--border-width);
            background-color: var(--tv-outline);
            border-radius: var(--pixel-unit);
            transition: all 0.3s ease;
        }

        .slider.dimmed .slider-line {
            background-color: var(--tv-body);
        }

        /* Style for the lights off label */
        .lights-label {
            font-family: 'Press Start 2P', cursive;
            font-size: calc(var(--pixel-unit) * 1);
            color: var(--knob-center);
            margin-top: calc(var(--pixel-unit) * 1.0); /* Reduced margins slightly */
            margin-bottom: calc(var(--pixel-unit) * 1.0);
            text-transform: uppercase;
            letter-spacing: 1px;
            line-height: 1.2;
            transition: all 0.3s ease;
        }

        .lights-label.dimmed {
            color: var(--tv-outline);
        }

        /* --- TV Feet --- */
        .tv-feet {
            position: absolute;
            bottom: calc(var(--element-gap) * -2 - var(--border-width));
            left: 0;
            width: 100%;
            height: calc(var(--pixel-unit) * 4);
            display: flex;
            justify-content: space-between;
            padding: 0 calc(var(--pixel-unit) * 10);
            box-sizing: border-box;
        }

        .foot {
            width: calc(var(--pixel-unit) * 12);
            height: 120%;
            background-color: var(--tv-body);
            border: var(--outline-width) solid var(--tv-outline);
            border-radius: calc(var(--pixel-unit) * 2);
            box-shadow:
                calc(var(--pixel-unit) * 0.8) calc(var(--pixel-unit) * 0.8) 0 var(--tv-outline),
                calc(var(--pixel-unit) * 1.5) calc(var(--pixel-unit) * 1.5) 0 rgba(0,0,0,0.2);
        }

        /* --- YouTube Player & Overlays --- */
        #player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
        }

        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 8;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s linear;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .screen-overlay.visible {
            opacity: 1;
        }

        .loading {
            color: var(--loading-text);
            font-size: calc(var(--pixel-unit) * 2.5); /* Slightly smaller */
            text-shadow: var(--pixel-unit) var(--pixel-unit) 0 var(--tv-outline);
            z-index: 10;
            text-align: center; /* Allow multi-line */
            padding: var(--pixel-unit);
        }

        /* Improved static effect using CSS animation */
        .static {
            background-color: #000;
            z-index: 9;
            opacity: 0;
            overflow: hidden;
        }

        .static.visible {
            opacity: 0.7;
        }

        .static:before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background-image:
                repeating-radial-gradient(circle at 15% 15%, white, black 1px),
                repeating-radial-gradient(circle at 85% 85%, white, black 1px);
            background-size:
                calc(var(--pixel-unit) * 3) calc(var(--pixel-unit) * 3),
                calc(var(--pixel-unit) * 5) calc(var(--pixel-unit) * 5);
            opacity: 0.3;
            animation: staticAnimation 0.2s infinite alternate;
        }

        @keyframes staticAnimation {
            0% { background-position: 0 0, 0 0; opacity: 0.2; }
            25% { background-position: -1px 1px, 1px -1px; opacity: 0.3; }
            50% { background-position: 1px 2px, -1px -2px; opacity: 0.25; }
            75% { background-position: -2px -1px, 2px 1px; opacity: 0.3; }
            100% { background-position: 2px -2px, -2px 2px; opacity: 0.35; }
        }

        .color-bars {
            z-index: 7;
            background-color: transparent;
            opacity: 0.5;
        }

        .color-bars.visible {
            opacity: 0.5;
        }

        .color-bar {
            flex-grow: 1;
            height: 100%;
        }
        .color-bar-1 { background-color: #ff0000; } .color-bar-2 { background-color: #ff8000; }
        .color-bar-3 { background-color: #ffff00; } .color-bar-4 { background-color: #00ff00; }
        .color-bar-5 { background-color: #0000ff; } .color-bar-6 { background-color: #4b0082; }
        .color-bar-7 { background-color: #8b00ff; }

        /* --- Dim Lights Button (Hidden) --- */
        .dim-lights-btn { display: none; }

        /* --- Viewport Dimmer --- */
        .viewport-dimmer {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: var(--dimmed-overlay);
            z-index: -1; opacity: 0;
            transition: opacity 0.5s ease; pointer-events: none;
        }
        .viewport-dimmer.active { opacity: 1; }

    </style>
</head>
<body>
    <!-- Dimmer overlay for the entire viewport -->
    <div class="viewport-dimmer" id="viewport-dimmer"></div>

    <!-- Authentication Controls -->
    <div class="auth-controls">
        <!-- Container for Google Sign-In Button -->
        <div id="g_id_onload"
             data-client_id="YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com" <!-- <<< REPLACE THIS with your actual Google Client ID -->
             data-callback="handleCredentialResponse"
             data-auto_select="false">
        </div>
        <div class="g_id_signin"
             data-type="standard"
             data-size="large"
             data-theme="outline" /* Changed theme for better visibility on potentially colorful background */
             data-text="signin_with"
             data-shape="rectangular"
             data-logo_alignment="left">
        </div>
        <!-- Sign Out Button (Initially Hidden) -->
        <button id="signout-button" style="display: none;">Sign Out</button>
    </div>


    <!-- Main Heading -->
    <h1 class="main-heading">shuffle_bot</h1>

    <!-- Main TV Container -->
    <div class="tv-container" id="tv-container">
        <!-- TV Body Structure -->
        <div class="tv-body">

            <!-- Screen Area (Left) -->
            <div class="screen-area">
                <div class="screen">
                    <!-- YouTube Player Div -->
                    <div id="player"></div>
                    <!-- Overlays -->
                    <div class="screen-overlay color-bars" id="color-bars-overlay">
                        <div class="color-bar color-bar-1"></div> <div class="color-bar color-bar-2"></div>
                        <div class="color-bar color-bar-3"></div> <div class="color-bar color-bar-4"></div>
                        <div class="color-bar color-bar-5"></div> <div class="color-bar color-bar-6"></div>
                        <div class="color-bar color-bar-7"></div>
                    </div>
                    <div class="screen-overlay static" id="static-overlay"></div>
                    <div class="screen-overlay loading" id="loading-overlay">LOADING...</div>
                </div>
            </div>

            <!-- Controls Panel (Right) - UPDATED STRUCTURE -->
            <div class="controls-panel">
                <!-- Control Group: Channel -->
                <div class="control-group">
                    <div class="control knob-1" id="channel-knob" title="Shuffle Video"></div>
                    <span class="control-label">Shuffle</span>
                </div>
                <!-- Control Group: Mute -->
                <div class="control-group">
                    <div class="control knob-2" id="mute-knob" title="Toggle Mute"></div>
                    <span class="control-label">Mute</span>
                </div>
                <!-- Control Group: Save to Watch Later -->
                <div class="control-group">
                     <!-- Save Button (Initially hidden/disabled) -->
                    <button id="save-watch-later-button" class="control" title="Save to Watch Later" style="display: none;" disabled>ðŸ’¾</button>
                    <span class="control-label">Save</span>
                </div>
                <!-- Control Group: Dim Lights Slider -->
                <div class="control-group">
                    <div class="control slider" id="dim-slider" title="Toggle Dim Lights">
                        <div class="slider-line"></div>
                        <div class="slider-line"></div>
                    </div>
                    <span class="lights-label" id="lights-label">Lights Off</span>
                </div>
            </div>

             <!-- TV Feet -->
            <div class="tv-feet">
                <div class="foot foot-left"></div>
                <div class="foot foot-right"></div>
            </div>

        </div><!-- End tv-body -->
    </div><!-- End tv-container -->

    <!-- JavaScript Section -->
    <script>
        // --- Configuration ---
        let player;
        let apiAttemptCount = 0; // Renamed to avoid confusion with player errors
        const MAX_API_ATTEMPTS = 5; // Max attempts to fetch from API
        const MIN_VIDEO_DURATION = 20;  // Minimum video duration in seconds
        const MAX_VIDEO_DURATION = 600; // Maximum video duration in seconds (10 minutes)

        // ----- CONFIGURATION OPTIONS -----
        const CONFIG = {
            initialVolume: 70,
            channelChangeDelay: 200,    // Shortened delay as API call takes time
            effectDuration: 300,
            useYouTubeAPI: true,
            useStaticEffect: true,
            // autoLoadVideo: false // No longer strictly needed, depends on sign-in state
            googleClientId: 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com' // <<< REPLACE THIS with your actual Google Client ID
        };

        // --- Global Variables ---
        let isLoading = false;
        let isMuted = false;
        let currentVideoId = null;
        let isDimmed = false;
        let isInitialized = false; // Player initialized
        let googleUserAccessToken = null;
        let tokenClient; // Google Identity Services Token Client

        // --- DOM Element References ---
        const channelKnob = document.getElementById('channel-knob');
        const muteKnob = document.getElementById('mute-knob');
        const saveButton = document.getElementById('save-watch-later-button');
        const dimSlider = document.getElementById('dim-slider');
        const staticOverlay = document.getElementById('static-overlay');
        const colorBarsOverlay = document.getElementById('color-bars-overlay');
        const loadingOverlay = document.getElementById('loading-overlay');
        const lightsLabel = document.getElementById('lights-label');
        const tvContainer = document.getElementById('tv-container');
        const viewportDimmer = document.getElementById('viewport-dimmer');
        const bodyElement = document.body;
        const signOutButton = document.getElementById('signout-button');
        const signInButtonContainer = document.querySelector('.g_id_signin'); // Reference to hide/show

        // --- Google Identity Services Functions ---

        function initializeGis() {
            if (!CONFIG.googleClientId || CONFIG.googleClientId.startsWith('YOUR_GOOGLE_CLIENT_ID')) {
                 console.error("Google Client ID not set in CONFIG. Please replace placeholder.");
                 // Optionally display an error to the user
                 showOverlay(loadingOverlay, "CONFIG ERROR:\nMissing Google Client ID");
                 return;
             }

            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CONFIG.googleClientId,
                scope: 'https://www.googleapis.com/auth/youtube.force-ssl', // Scope needed for Watch Later
                callback: (tokenResponse) => { // Callback function for the token client
                    if (tokenResponse && tokenResponse.access_token) {
                        googleUserAccessToken = tokenResponse.access_token;
                        console.log("Access Token obtained!");
                        updateAuthUI(true); // Update UI to logged-in state
                        // If player is ready, load the first video now that we are logged in
                        if (isInitialized && !currentVideoId) {
                            fetchAndLoadYouTubeVideo();
                        }
                    } else {
                         console.error("Failed to get access token from response:", tokenResponse);
                         handleSignOut(); // Ensure clean state if token fails
                    }
                },
                 error_callback: (error) => {
                    console.error('GSI Token Client Error:', error);
                    // Handle errors like user closing the popup, denying permissions etc.
                     googleUserAccessToken = null; // Ensure token is null on error
                     updateAuthUI(false);
                     showOverlay(loadingOverlay, "SIGN-IN FAILED\nOR CANCELLED");
                     hideVCRStaticEffect();
                 }
            });
             console.log("GIS Token Client Initialized.");
        }

        // Called by Google Library after user selects account from the button
        function handleCredentialResponse(response) {
            console.log("Credential Response Received (JWT): ", response.credential);
            // We don't use the JWT directly for API calls, but useful for basic info if needed
            // Now request the OAuth 2.0 access token.
            requestAccessToken();
        }

        function requestAccessToken() {
             if (tokenClient) {
                 // Prompt the user for authorization. '' tries to do it silently if possible.
                 // 'consent' forces consent screen, 'select_account' forces account chooser.
                 tokenClient.requestAccessToken({prompt: ''});
             } else {
                 console.error("Token Client not initialized before requesting token.");
             }
        }

        function handleSignOut() {
            if (googleUserAccessToken) {
                google.accounts.oauth2.revoke(googleUserAccessToken, () => {
                    console.log('Access token revoked.');
                });
            }
            googleUserAccessToken = null;
            google.accounts.id.disableAutoSelect(); // Don't auto sign-in next time
            updateAuthUI(false); // Update UI to logged-out state
            currentVideoId = null; // Clear current video
            if(player && isInitialized) {
                 player.stopVideo(); // Stop playback
                 player.clearVideo();
            }
            showOverlay(loadingOverlay, "PLEASE SIGN IN\nTO SHUFFLE");
            hideVCRStaticEffect();
        }

        function updateAuthUI(isSignedIn) {
             if (isSignedIn) {
                 signOutButton.style.display = 'block';
                 signInButtonContainer.style.display = 'none'; // Hide Google's sign-in button
                 // Enable shuffle knob if it was disabled
                 channelKnob.disabled = false;
                 // Save button state managed by player state change
             } else {
                 signOutButton.style.display = 'none';
                 signInButtonContainer.style.display = 'block'; // Show Google's sign-in button
                 saveButton.style.display = 'none'; // Hide save button
                 saveButton.disabled = true;
                 // Disable shuffle knob until signed in
                 channelKnob.disabled = true; // Prevent shuffling when logged out
             }
        }

        // --- YouTube Player & API Functions ---

        function loadYouTubeAPI() {
            if (CONFIG.useYouTubeAPI) {
                console.log("Loading YouTube API...");
                const tag = document.createElement('script');
                tag.src = "https://www.youtube.com/iframe_api";
                document.body.appendChild(tag);
            } else {
                console.log("YouTube API loading disabled.");
                showOverlay(loadingOverlay, "YT API DISABLED");
            }
        }

        function onYouTubeIframeAPIReady() {
            if (!CONFIG.useYouTubeAPI) return;
            console.log("YouTube API Ready. Initializing Player.");
            // Don't show loading overlay yet, wait for sign-in or player ready
            player = new YT.Player('player', {
                height: '100%', width: '100%', videoId: '',
                playerVars: { 'autoplay': 0, 'controls': 0, 'showinfo': 0, 'rel': 0, 'iv_load_policy': 3, 'modestbranding': 1, 'playsinline': 1 },
                events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateChange, 'onError': onPlayerError }
            });
        }

        function onPlayerReady(event) {
            if (!CONFIG.useYouTubeAPI) return;
            console.log("Player Ready");
            isInitialized = true;
            event.target.setVolume(CONFIG.initialVolume);
            isMuted = false;

            // Player is ready, but don't load video yet. Wait for sign-in.
            if (!googleUserAccessToken) {
                 showOverlay(loadingOverlay, "PLEASE SIGN IN");
                 updateAuthUI(false); // Ensure UI reflects logged-out state
            } else {
                // If already signed in when player becomes ready, load first video
                 fetchAndLoadYouTubeVideo();
            }
        }

        function showVCRStaticEffect() {
            if (CONFIG.useStaticEffect) {
                showOverlay(staticOverlay);
                showOverlay(colorBarsOverlay);
            }
        }

        function hideVCRStaticEffect() {
            hideOverlay(staticOverlay);
            hideOverlay(colorBarsOverlay);
        }

        function onPlayerStateChange(event) {
            if (!CONFIG.useYouTubeAPI || !player) return;
            const state = event.data;
            console.log("Player State Changed:", state);

            if (state === YT.PlayerState.PLAYING) {
                hideOverlay(loadingOverlay);
                hideVCRStaticEffect();
                isLoading = false;
                apiAttemptCount = 0; // Reset API attempt counter on successful play

                 // Enable save button only if logged in and video is valid
                 if (googleUserAccessToken) {
                     const duration = player.getDuration();
                     if (duration >= MIN_VIDEO_DURATION && duration <= MAX_VIDEO_DURATION) {
                         saveButton.style.display = 'flex'; // Use flex to center icon
                         saveButton.disabled = false;
                         saveButton.textContent = 'ðŸ’¾'; // Reset icon
                     } else {
                         console.log('Video duration outside acceptable range:', duration);
                          saveButton.style.display = 'none'; // Hide if duration invalid
                          saveButton.disabled = true;
                         fetchAndLoadYouTubeVideo(); // Load a new one immediately
                         return;
                     }
                 } else {
                      saveButton.style.display = 'none';
                      saveButton.disabled = true;
                 }

            } else if (state === YT.PlayerState.ENDED) {
                console.log("Video Ended - Loading next video.");
                saveButton.style.display = 'none'; // Hide save button
                saveButton.disabled = true;
                fetchAndLoadYouTubeVideo(); // Auto-shuffle next video
            } else if (state === YT.PlayerState.BUFFERING || state === YT.PlayerState.UNSTARTED || state === YT.PlayerState.CUED) {
                 if (!isLoading) { // Show loading only if we aren't already in a loading state
                     showOverlay(loadingOverlay, "BUFFERING...");
                     showVCRStaticEffect();
                 }
                 saveButton.style.display = 'none'; // Hide save button while not playing
                 saveButton.disabled = true;
            } else {
                 // Handle other states like PAUSED if needed
                 // Hide save button if paused? Optional.
                 // saveButton.style.display = 'none';
                 // saveButton.disabled = true;
            }
        }

        function onPlayerError(event) {
            if (!CONFIG.useYouTubeAPI) return;
            console.error("Player Error:", event.data, "Video ID:", currentVideoId);
             saveButton.style.display = 'none'; // Hide save button on error
             saveButton.disabled = true;
             isLoading = false; // Allow fetching new video

             // Errors 2, 100, 101, 150 usually mean the video is bad (invalid, private, not embeddable)
             // Try fetching a new video immediately in these cases.
             if (event.data === 2 || event.data === 100 || event.data === 101 || event.data === 150) {
                 console.log("Player error indicates bad video, fetching new one.");
                 setTimeout(fetchAndLoadYouTubeVideo, 500); // Short delay before retry
             } else {
                 // For other errors, maybe wait a bit longer
                  console.log("Unexpected player error, retrying after longer delay.");
                 setTimeout(fetchAndLoadYouTubeVideo, 2000);
             }
        }

        // --- Core Logic: Fetching and Loading Video ---

        async function fetchAndLoadYouTubeVideo() {
             if (!CONFIG.useYouTubeAPI || !isInitialized) {
                 console.log("Load cancelled: YouTube API disabled or player not ready.");
                 return;
             }
             if (!googleUserAccessToken) {
                 console.warn("Cannot fetch video: User not signed in.");
                 showOverlay(loadingOverlay, "PLEASE SIGN IN\nTO SHUFFLE");
                 hideVCRStaticEffect();
                 isLoading = false;
                 return;
             }
             if (isLoading) {
                 console.log("Load cancelled: Already loading/fetching.");
                 return;
             }

             console.log("Fetching new random video via API (User Authenticated)...");
             isLoading = true;
             apiAttemptCount++; // Increment API attempt counter

             showOverlay(loadingOverlay, "SEARCHING..."); // Update loading text
             showVCRStaticEffect();
             saveButton.style.display = 'none'; // Hide save button during load
             saveButton.disabled = true;

             const videoId = await fetchRandomYouTubeVideoIdAuthenticated();

             if (videoId && player) {
                 currentVideoId = videoId;
                 console.log("Loading video ID:", videoId);
                 // Use the channel change delay before actually loading into player
                 setTimeout(() => {
                     if (player && typeof player.loadVideoById === 'function') {
                         player.loadVideoById(videoId);
                         // Effects hiding and button enabling are handled by onPlayerStateChange
                     } else {
                          console.error("Player not available to load video.");
                          isLoading = false; // Reset state
                     }
                 }, CONFIG.channelChangeDelay);
             } else {
                 console.error("Failed to get a video ID using user token.");
                 isLoading = false; // Allow retry
                 hideOverlay(loadingOverlay);
                 hideVCRStaticEffect();
                 // Handle failure - check attempt count
                 if (apiAttemptCount < MAX_API_ATTEMPTS) {
                     console.log(`Retrying API fetch (${apiAttemptCount}/${MAX_API_ATTEMPTS})`);
                     setTimeout(fetchAndLoadYouTubeVideo, 1500); // Retry after delay
                 } else {
                     console.error("Max API fetch attempts reached.");
                     showOverlay(loadingOverlay, "ERROR FINDING VIDEO\nPLEASE TRY AGAIN LATER");
                     apiAttemptCount = 0; // Reset counter after max failure
                 }
             }
         }

         async function fetchRandomYouTubeVideoIdAuthenticated() {
              if (!googleUserAccessToken) return null;

             const randomQuery = generateRandomSearchTerm();
             const maxResults = 20; // Fetch a bit more results for better random chance
             // YouTube API V3 Search Endpoint
             const url = `https://www.googleapis.com/youtube/v3/search` +
                       `?part=snippet` +
                       `&q=${encodeURIComponent(randomQuery)}` +
                       `&type=video` +
                       `&videoEmbeddable=true` +
                       `&maxResults=${maxResults}` +
                       // Filter by duration (less precise than player check, but helps)
                       // Options: 'any', 'long', 'medium', 'short'
                       `&videoDuration=medium` +
                       // Request only the fields we need to reduce data transfer
                       `&fields=items(id(videoId))`;


             try {
                 const response = await fetch(url, {
                     method: 'GET',
                     headers: {
                         'Authorization': `Bearer ${googleUserAccessToken}`,
                         'Accept': 'application/json'
                     }
                 });

                 if (response.status === 401 || response.status === 403) {
                      console.error("Authorization error (token might be expired or invalid). Signing out.");
                      handleSignOut(); // Force sign out on auth error
                      showOverlay(loadingOverlay, "AUTH ERROR\nPLEASE SIGN IN AGAIN");
                      return null;
                  }

                 if (!response.ok) {
                     const errorData = await response.json().catch(() => ({})); // Try to parse error, default to empty obj
                     console.error("YouTube API Error (Authenticated Search):", response.status, errorData);
                     throw new Error(`YouTube API Search Error: ${errorData.error?.message || response.statusText}`);
                 }
                 const data = await response.json();

                 if (data.items && data.items.length > 0) {
                     // Filter results further if needed (e.g., remove channels if accidentally included)
                     const validItems = data.items.filter(item => item.id && item.id.videoId);
                     if (validItems.length > 0) {
                          const randomIndex = Math.floor(Math.random() * validItems.length);
                          const videoId = validItems[randomIndex].id.videoId;
                          console.log("Found video via Authenticated API:", videoId, "for query:", randomQuery);
                          return videoId;
                     } else {
                          console.warn("API search yielded results, but no valid video IDs found for:", randomQuery);
                          return null;
                     }
                 } else {
                     console.warn("Authenticated API search yielded no results for:", randomQuery);
                     return null;
                 }
             } catch (error) {
                 console.error("Error fetching authenticated from YouTube API:", error);
                 return null;
             }
         }

         async function saveCurrentVideoToWatchLater() {
             if (!googleUserAccessToken) {
                 console.warn("Cannot save: User not signed in.");
                 // Optionally show a quick message
                 return;
             }
             if (!currentVideoId || !player || player.getPlayerState() !== YT.PlayerState.PLAYING) {
                 console.warn("Cannot save: No valid video playing.");
                 return;
             }

             console.log(`Attempting to save video ${currentVideoId} to Watch Later...`);
             saveButton.disabled = true;
             saveButton.textContent = 'ðŸ’¾..'; // Indicate loading state on button

             const url = 'https://www.googleapis.com/youtube/v3/playlistItems?part=snippet';
             const requestBody = {
                 snippet: {
                     playlistId: 'WL', // Special ID for "Watch Later"
                     resourceId: {
                         kind: 'youtube#video',
                         videoId: currentVideoId
                     }
                 }
             };

             try {
                 const response = await fetch(url, {
                     method: 'POST',
                     headers: {
                         'Authorization': `Bearer ${googleUserAccessToken}`,
                         'Accept': 'application/json',
                         'Content-Type': 'application/json'
                     },
                     body: JSON.stringify(requestBody)
                 });

                 const responseData = await response.json().catch(() => ({})); // Try parsing JSON, default empty

                 if (response.status === 401 || response.status === 403) {
                     console.error("Authorization error saving. Signing out.");
                     handleSignOut();
                     showOverlay(loadingOverlay, "AUTH ERROR\nPLEASE SIGN IN AGAIN");
                     saveButton.textContent = 'ðŸ’¾'; // Reset icon
                     return; // Exit function
                 }

                 if (!response.ok) {
                      console.error("Error saving to Watch Later:", response.status, responseData);
                      let errorMsg = responseData.error?.message || response.statusText;
                      // Handle specific case: Video already in playlist
                      if (responseData.error?.errors?.[0]?.reason === 'playlistItemDuplicatesNotAllowed') {
                           errorMsg = "Already in Watch Later";
                           saveButton.textContent = 'âœ…'; // Show as success even if duplicate
                           setTimeout(() => { if (!saveButton.disabled) saveButton.textContent = 'ðŸ’¾'; }, 1500);
                      } else {
                           showOverlay(loadingOverlay, `SAVE FAILED:\n${errorMsg}`); // Show error on screen
                           setTimeout(hideOverlay, 2500, loadingOverlay); // Hide error after delay
                           saveButton.textContent = 'âŒ'; // Show error icon
                           setTimeout(() => { if (!saveButton.disabled) saveButton.textContent = 'ðŸ’¾'; }, 1500);
                      }
                 } else {
                     console.log(`Video ${currentVideoId} successfully added/found in Watch Later.`);
                     saveButton.textContent = 'âœ…'; // Show success icon
                      setTimeout(() => { if (!saveButton.disabled) saveButton.textContent = 'ðŸ’¾'; }, 1500); // Reset after delay
                 }

             } catch (error) {
                 console.error("Network or other error saving to Watch Later:", error);
                  showOverlay(loadingOverlay, "SAVE FAILED:\nNetwork Error");
                  setTimeout(hideOverlay, 2500, loadingOverlay);
                  saveButton.textContent = 'âŒ';
                  setTimeout(() => { if (!saveButton.disabled) saveButton.textContent = 'ðŸ’¾'; }, 1500);
             } finally {
                 // Re-enable button unless an auth error occurred (handled by handleSignOut)
                 if (googleUserAccessToken) {
                      saveButton.disabled = false;
                 }
             }
         }


        // --- Helper Functions ---

        function generateRandomSearchTerm() {
             // Expanded list for more variety
            const words = [
                "8-bit music", "pixel art tutorial", "retro gaming", "synthwave mix", "lofi hip hop radio",
                "funny cat compilation", "dog zoomies", "fail compilation", "gameplay highlights", "speedrun",
                "science explained", "space documentary", "nature relaxation", "ambient music", "live music performance",
                "acoustic cover", "comedy sketch", "short film animation", "stop motion", "vlog daily",
                "tech review", "unboxing", "cooking recipe", "baking tutorial", "woodworking project", "asmr",
                "city ambience", "rain sounds", "ocean waves", "meditation music", "yoga class", "workout routine"
            ];
            return words[Math.floor(Math.random() * words.length)];
        }

        function showOverlay(overlayElement, text = null) {
            if (overlayElement) {
                // Update text only for the loading overlay
                if (text && overlayElement === loadingOverlay) {
                    // Use innerHTML to render line breaks from \n
                    loadingOverlay.innerHTML = text.replace(/\n/g, '<br>');
                } else if (overlayElement === loadingOverlay && !text) {
                     loadingOverlay.textContent = "LOADING..."; // Default
                }
                overlayElement.classList.add('visible');
            }
        }

        function hideOverlay(overlayElement) {
            if (overlayElement) {
                overlayElement.classList.remove('visible');
                // Reset loading text when hiding
                if (overlayElement === loadingOverlay) {
                     loadingOverlay.textContent = "LOADING...";
                }
            }
        }

        function toggleMute() {
            if (!player || typeof player.isMuted !== 'function' || !isInitialized) return;
            if (player.isMuted()) {
                player.unMute();
                isMuted = false;
                console.log("Player Unmuted");
                muteKnob.style.filter = 'brightness(1)';
            } else {
                player.mute();
                isMuted = true;
                console.log("Player Muted");
                muteKnob.style.filter = 'brightness(0.7)';
            }
        }

        function toggleDimLights() {
            isDimmed = !isDimmed;
            console.log("Dim Lights Toggled:", isDimmed);
            bodyElement.classList.toggle('dimmed', isDimmed);
            tvContainer.classList.toggle('dimmed', isDimmed);
            viewportDimmer.classList.toggle('active', isDimmed);
            dimSlider.classList.toggle('dimmed', isDimmed);
            lightsLabel.classList.toggle('dimmed', isDimmed);
            lightsLabel.textContent = isDimmed ? "Lights On" : "Lights Off"; // Update label text
        }

        // --- Event Listeners Setup ---
        function setupEventListeners() {
             // Use fetchAndLoadYouTubeVideo for the shuffle knob
            channelKnob.addEventListener('click', () => {
                 if (!channelKnob.disabled) { // Check if knob is enabled (user is logged in)
                    fetchAndLoadYouTubeVideo();
                 } else {
                      console.log("Shuffle disabled. Please sign in.");
                      showOverlay(loadingOverlay, "PLEASE SIGN IN\nTO SHUFFLE");
                      hideVCRStaticEffect();
                 }
            });
            muteKnob.addEventListener('click', toggleMute);
            dimSlider.addEventListener('click', toggleDimLights);
            saveButton.addEventListener('click', saveCurrentVideoToWatchLater);
            signOutButton.addEventListener('click', handleSignOut);
        }

        // --- Initialization ---
        // Using window.onload to ensure GIS library is ready
         window.onload = function () {
             console.log("Window loaded. Initializing GIS and setting up app.");
             initializeGis(); // Initialize Google Identity Services first
             setupEventListeners();
             loadYouTubeAPI(); // Load YouTube API now
             updateAuthUI(false); // Start in logged-out UI state
         };

    </script>

</body>
</html>